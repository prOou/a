# %%
#practical 1

import cv2
import matplotlib.pyplot as plt


img = "1.png"
img = cv2.imread(img)
if img is not None:

    # cv2.imshow("original",img)
    # img=cv2.resize(img,(900,500)) #resized
    grey = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)  #bgr_> grey
    _,bNw = cv2.threshold(grey,0,255,cv2.THRESH_BINARY + cv2.THRESH_OTSU) #grey -> black & white
    
    #split image
    b = img[:,:,0]
    g = img[:,:,1]
    r = img[:,:,2]
    merged = cv2.merge([b,g,r])
    
    cv2.imshow("blue",b)
    cv2.imshow("green",g)
    cv2.imshow("RED",r)
    
    cv2.imshow("resized",img)
    cv2.imshow("grey",grey)
    cv2.imshow("black&white",bNw)
    cv2.imshow("merged",merged)
    
    
    cv2.waitKey(0)
    
    
    plt.figure()
    plt.title("Gray image profile")
    plt.xlabel("pixel intensity")
    plt.ylabel("frequency")
    plt.hist(grey.ravel(),bins=256,range=[0,256])
    plt.show()
    
    cv2.imwrite("grey.jpg",grey)
    cv2.imwrite("b&w.jpg",bNw)
    cv2.imwrite("resized.jpg",img)
    cv2.destroyAllWindows()

# %%
#practical 2


import cv2 , numpy as np , matplotlib.pyplot as plt

img = cv2.imread("1.png",cv2.IMREAD_GRAYSCALE)

# cv2.namedWindow("window",cv2.WINDOW_NORMAL)
# cv2.imshow("window",img)
if img is not None:
    # img = cv2.resize(img,(900,500))
    flip_horizontal = cv2.flip(img,1)
    flip_vertical = cv2.flip(img,0)
    negativeImg = 255 - img
    ret , binary = cv2.threshold(img,127,255,cv2.THRESH_BINARY)
    # normalized = cv2.normalize(rimg,None,alpha=0,beta=255,norm_type=cv2.NORM_MINMAX)
    
    rmin = np.min(img)
    rmax = np.max(img)
    
    normalized = (((img.astype(np.float64)-rmin)  / (rmax-rmin))*255).astype(np.uint8)
    cv2.imshow("original img",img)
    cv2.imshow("negativeImg",negativeImg)
    cv2.imshow("Horizontal flip ",flip_horizontal)
    cv2.imshow("Vertical flip ",flip_vertical)
    cv2.imshow("Binary Threshold ",binary)
    cv2.imshow("Normalized",normalized)
    # print(np.min(img))
    # print(np.min(normalized))
    
    plt.figure()
    plt.title("histogram")
    plt.xlabel("intensity")
    plt.xlabel("frequency")
    plt.hist(img.ravel(),bins=255,range=[0,255],label="original")
    plt.hist(normalized.ravel(),bins=255,range=[0,255],label="normalized")
    plt.legend()
    plt.show()
    cv2.waitKey(0)
    
    cv2.imwrite("negative image.jpg",negativeImg)
    cv2.imwrite("flip horizonntal.jpg",flip_horizontal)
    cv2.imwrite("flip vertical.jpg",flip_vertical)
    cv2.imwrite("bianry threshold.jpg",binary)
    cv2.imwrite("normalised image.jpg",normalized)
    cv2.destroyAllWindows()

# %%
# practical 3

import cv2, numpy as np
img1 = cv2.imread("1.png",cv2.IMREAD_COLOR) 
img2 = cv2.imread("2.jpg",cv2.IMREAD_COLOR) 
if img1 is not None and img2 is not None:
    # img1=cv2.resize(img1,(700,400))
    img2=cv2.resize(img2,(512,512))
    img1float=img1.astype(np.float64)
    img2float=img2.astype(np.float64)
    
    add = cv2.add(img2,img1)
    subtract12 = cv2.subtract(img1,img2)
    subtract21 = cv2.subtract(img2,img1)
    
    mean = cv2.mean(img1)[0:3]
    
    
    target = 100
    currentMean=np.mean(img1float)
    scale = target/currentMean
    
    bbrightnessAdjusted = np.clip(img1float*scale,0,255).astype(np.uint8)
    print("mean",mean)
    # cv2.imshow("img1",img1)
    # cv2.imshow("img2",img2)
    
    
    cv2.imshow("add",add)
    cv2.imshow("subtract12",subtract12)
    cv2.imshow("subtract21",subtract21)
    cv2.imshow("bbrightnessadjusted.jpg",bbrightnessAdjusted)
    
    
    cv2.imwrite("add.jpg",add)
    cv2.imwrite("subtract12.jpg",subtract12)
    cv2.imwrite("subtract21.jpg",subtract21)
    cv2.imwrite("bbrightnessadjusted.jpg",bbrightnessAdjusted)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

# %%
#practical 4
import cv2
import numpy as np
import matplotlib.pyplot as plt


height, width = 300, 300

# Image 1: A White Rectangle
img1 = np.zeros((height, width), dtype=np.uint8)
cv2.rectangle(img1, (50, 50), (250, 250), 255, -1) # -1 fills the shape

# Image 2: A White Circle
img2 = np.zeros((height, width), dtype=np.uint8)
cv2.circle(img2, (150, 150), 120, 255, -1)




# (a) AND Operation
# Logic: 1 & 1 = 1 (White & White = White). All else is Black.
# Used for: Intersection, Masking.
and_op = cv2.bitwise_and(img1, img2)

# (b) OR Operation
# Logic: 1 | 0 = 1. If pixel is white in EITHER image, it stays white.
# Used for: Merging images.
or_op = cv2.bitwise_or(img1, img2)

# (c) Intersection
# Mathematically, the Intersection of two sets is the AND operation.
intersection_op = cv2.bitwise_and(img1, img2)

# (d) Watermarking using XOR
# Logic: A XOR B = C. Crucially, C XOR B = A. 
# This reversibility makes it useful for cryptography/watermarking.
watermark_pattern = img2 # Using the circle as the watermark
original_image = img1    # Using the rectangle as the main image

# 1. Apply Watermark (Encrypt)
encrypted_img = cv2.bitwise_xor(original_image, watermark_pattern)

# 2. Remove Watermark (Decrypt) to prove it works
decrypted_img = cv2.bitwise_xor(encrypted_img, watermark_pattern)

# (e) NOT Operation (Negative)
# Logic: Inverts bits. 0 becomes 255 (White), 255 becomes 0 (Black).
not_op = cv2.bitwise_not(img1)


titles = [
    "Image 1 (Rect)", "Image 2 (Circle)",
    "(a) AND / (c) Intersection", "(b) OR Operation",
    "(d) XOR (Watermarked)", "(d) XOR (Recovered)",
    "(e) NOT (Negative Img1)", "NOT (Negative Img2)"
]

images = [
    img1, img2,
    and_op, or_op,
    encrypted_img, decrypted_img,
    not_op, cv2.bitwise_not(img2)
]

plt.figure(figsize=(14, 8))
for i in range(8):
    plt.subplot(2, 4, i+1)
    plt.imshow(images[i], cmap='gray')
    plt.title(titles[i])
    plt.axis('off')

plt.tight_layout()
plt.show()

# %%
#practical 5
import cv2
import numpy as np
import matplotlib.pyplot as plt


img = cv2.imread('1.png', 0)

# ==========================================
# A. Using Inbuilt Functions (OpenCV)
# ==========================================

# 1. Calculate Histogram
# cv2.calcHist(images, channels, mask, histSize, ranges)
hist_inbuilt = cv2.calcHist([img], [0], None, [256], [0, 256])

# 2. Equalize Histogram
eq_inbuilt = cv2.equalizeHist(img)


# ==========================================
# B. Without Using Inbuilt Functions (Manual)
# ==========================================

# 1. Calculate Histogram Manually
# Flatten image to 1D array to iterate easily
flat = img.flatten()
hist_manual = np.zeros(256, dtype=int)

# Count frequency of each pixel value
# (Using numpy for speed, but logic is: for pixel in img: hist[pixel] += 1)
for pixel in flat:
    hist_manual[pixel] += 1

# 2. Equalize Histogram Manually
# Algorithm:
#   a. Calculate Probability Density Function (PDF)
#   b. Calculate Cumulative Distribution Function (CDF)
#   c. Multiply CDF by (L-1) where L=256 (max intensity levels)
#   d. Round values to get new mappings

# a. PDF
total_pixels = img.size
pdf = hist_manual / total_pixels

# b. CDF
cdf = np.zeros(256, dtype=float)
cumulative_sum = 0
for i in range(256):
    cumulative_sum += pdf[i]
    cdf[i] = cumulative_sum

# c. Calculate new intensity values (Transfer Function)
# Formula: s = round(cdf(r) * (L - 1))
L = 256
new_intensities = np.floor(cdf * (L - 1)).astype(np.uint8)

# d. Map old pixels to new pixels
# We create an empty image and fill it using the mapping array
eq_manual = new_intensities[flat].reshape(img.shape)


# ==========================================
# 3. Visualization & Comparison
# ==========================================
plt.figure(figsize=(12, 10))

# --- Row 1: Original Image & Histogram ---
plt.subplot(3, 2, 1)
plt.imshow(img, cmap='gray', vmin=0, vmax=255)
plt.title("Original Low-Contrast Image")
plt.axis('off')

plt.subplot(3, 2, 2)
plt.plot(hist_inbuilt, color='black')
plt.title("Original Histogram (Concentrated)")
plt.xlim([0, 256])

# --- Row 2: Inbuilt Result ---
plt.subplot(3, 2, 3)
plt.imshow(eq_inbuilt, cmap='gray', vmin=0, vmax=255)
plt.title("Equalized (OpenCV Inbuilt)")
plt.axis('off')

plt.subplot(3, 2, 4)
plt.hist(eq_inbuilt.flatten(), 256, [0, 256], color='blue', alpha=0.5)
plt.title("Histogram (Inbuilt)")

# --- Row 3: Manual Result ---
plt.subplot(3, 2, 5)
plt.imshow(eq_manual, cmap='gray', vmin=0, vmax=255)
plt.title("Equalized (Manual Implementation)")
plt.axis('off')

plt.subplot(3, 2, 6)
plt.hist(eq_manual.flatten(), 256, [0, 256], color='red', alpha=0.5)
plt.title("Histogram (Manual)")

plt.tight_layout()
plt.show()

# %%
#practicla 6
import cv2, numpy as np

img = cv2.imread("1.png",cv2.IMREAD_UNCHANGED)
if img is not None:
    # img = cv2.resize(img,(700,400),interpolation=cv2.INTER_AREA)
    h,w,c=img.shape
    tx,ty=50,30
    #translation
    translation_matrix = np.float32([[1,0,tx],[0,1,ty]])
    translation = cv2.warpAffine(img,translation_matrix,(w,h))
    cv2.imshow("translation",translation)
    
    #scaling
    scaleX,scaleY=1.5,1.5
    scaled= cv2.resize(img,None,fx=scaleX,fy=scaleY,interpolation=cv2.INTER_LINEAR)
    cv2.imshow("scaled",scaled)
    
    #rotation 
   
    rotationmatrix = cv2.getRotationMatrix2D(center=(w//2,h//2),angle=45,scale=1.5)
    rotatedImage = cv2.warpAffine(img,rotationmatrix,(w,h))
    cv2.imshow("rotated image",rotatedImage)
    
    #zooming
    zoom = img[h//4:3*h//4, w//4:3*w//4]
    zoomed = cv2.resize(zoom,(w,h),interpolation=cv2.INTER_LINEAR)
    cv2.imshow("zoomed",zoomed)
    
    cv2.imwrite("translation.jpg",translation)
    cv2.imwrite("scaled.jpg",scaled)
    cv2.imwrite("rotated image.jpg",rotatedImage)
    cv2.imwrite("zoomed.jpg",zoomed)

                



    
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    

# %%
import cv2
import numpy as np
import matplotlib.pyplot as plt

# --- Read image (grayscale) ---
# Ensure '1.png' exists in your folder
img_path = "1.png" 
img = cv2.imread(img_path, 0)
if img is None: 
    raise FileNotFoundError(f"Image not found at {img_path}")

# ========== (b) Add & Remove Salt-and-Pepper Noise ==========
sp_noisy = img.copy()
prob = 0.05
n = int(prob * img.size // 2)

# FIX: Use tuple() for indexing to avoid NumPy errors
coords = [np.random.randint(0, i - 1, n) for i in img.shape]
sp_noisy[tuple(coords)] = 255  # Salt (White)

coords = [np.random.randint(0, i - 1, n) for i in img.shape]
sp_noisy[tuple(coords)] = 0    # Pepper (Black)

# 1. Median filter (The standard solution for S&P)
sp_median = cv2.medianBlur(sp_noisy, 3)

# 2. Local Wiener Filter (Manual Implementation)
# We estimate local mean and variance to determine how much to smooth
k = 5
spf = sp_noisy.astype(np.float32)
mu  = cv2.boxFilter(spf, ddepth=-1, ksize=(k, k))
mu2 = cv2.boxFilter(spf*spf, ddepth=-1, ksize=(k, k))
var = np.maximum(mu2 - mu*mu, 0.0)

noise_est = np.mean(var) # Estimate overall noise variance
w = var / (var + noise_est + 1e-8) # Wiener weight
sp_wiener = mu + w * (spf - mu)
sp_wiener = np.clip(sp_wiener, 0, 255).astype(np.uint8)

# ========== (c) Add Gaussian Noise & Minimize ==========
# Gaussian noise is added to every pixel, not just some
sigma = 20.0
gauss = np.random.normal(0, sigma, img.shape).astype(np.float32)
gauss_noisy = np.clip(img.astype(np.float32) + gauss, 0, 255).astype(np.uint8)

# 1. Non-Local Means (State-of-the-art for Gaussian)
gauss_nlm = cv2.fastNlMeansDenoising(gauss_noisy, None, h=10, templateWindowSize=7, searchWindowSize=21)

# 2. Median (Included for comparison - usually blurs textures too much)
gauss_median = cv2.medianBlur(gauss_noisy, 3)

# 3. Local Wiener on Gaussian noise
gf = gauss_noisy.astype(np.float32)
gmu  = cv2.boxFilter(gf, -1, (k, k))
gmu2 = cv2.boxFilter(gf*gf, -1, (k, k))
gvar = np.maximum(gmu2 - gmu*gmu, 0.0)
gnoise = np.mean(gvar)
gw = gvar / (gvar + gnoise + 1e-8)
gauss_wiener = gmu + gw * (gf - gmu)
gauss_wiener = np.clip(gauss_wiener, 0, 255).astype(np.uint8)

# (a) General Restoration (Bilateral preserves edges while smoothing)
restored_bilateral = cv2.bilateralFilter(img, d=9, sigmaColor=75, sigmaSpace=75)

# ========== Show results ==========
titles = [
    "Original",
    "S&P Noisy", "Median (Best for S&P)", "Wiener (Blurry on S&P)",
    "Gaussian Noisy", "Median (Detail Loss)", "NLM (Best for Gauss)", "Wiener (Good)",
    "Bilateral (Smoothing)"
]
images = [
    img,
    sp_noisy, sp_median, sp_wiener,
    gauss_noisy, gauss_median, gauss_nlm, gauss_wiener,
    restored_bilateral
]

plt.figure(figsize=(14, 10))
for i, (t, im) in enumerate(zip(titles, images), 1):
    plt.subplot(3, 3, i)
    plt.imshow(im, cmap="gray")
    plt.title(t, fontsize=10)
    plt.axis("off")
plt.tight_layout()
plt.show()

# %%
#practical 8

import cv2
import numpy as np
import matplotlib.pyplot as plt

# ---- Read grayscale image ----
img = cv2.imread("1.png", 0)
if img is None: raise FileNotFoundError("Check the image path")

# ---- Add mild Gaussian noise (so low-pass denoises something) ----
sigma = 15.0
noise = np.random.normal(0, sigma, img.shape).astype(np.float32)
noisy = np.clip(img.astype(np.float32) + noise, 0, 255).astype(np.uint8)

# ---- 3x3 masks (kernels) ----
lowpass_box = np.ones((3,3), np.float32) / 9.0
lowpass_gauss = (1/16.0) * np.array([[1,2,1],[2,4,2],[1,2,1]], np.float32)
highpass = np.array([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]], np.float32)

# ---- 2-D convolution via filter2D ----
denoised_box = cv2.filter2D(noisy, -1, lowpass_box)     # Low-pass (average)
denoised_gauss = cv2.filter2D(noisy, -1, lowpass_gauss) # Low-pass (Gaussian)
edges = cv2.filter2D(img, -1, highpass)                 # High-pass (edges)

# ---- Show results ----
titles = ["Original", "Noisy", "Low-pass 3x3 (Box)", "Low-pass 3x3 (Gaussian)", "High-pass 3x3 (Edges)"]
images = [img, noisy, denoised_box, denoised_gauss, edges]

plt.figure(figsize=(12,6))
for i,(t,im) in enumerate(zip(titles, images), 1):
    plt.subplot(2,3,i)
    plt.imshow(im, cmap="gray")
    plt.title(t); plt.axis("off")
plt.tight_layout(); plt.show()

# (optional) save outputs
cv2.imwrite("noisy.png", noisy)
cv2.imwrite("lowpass_box.png", denoised_box)
cv2.imwrite("lowpass_gauss.png", denoised_gauss)
cv2.imwrite("highpass.png", edges)



# %%
#practical 9


import cv2
import numpy as np
import matplotlib.pyplot as plt

# ---- 1. Read grayscale image ----
img = cv2.imread(r"1.png", 0) 
if img is None: 
    raise FileNotFoundError("Image not found. Check the path '1.png'")

# Convert to float32 for processing
fimg = img.astype(np.float32)

# ---- 2. Compute FFT ----
F = np.fft.fft2(fimg)
Fshift = np.fft.fftshift(F)                 # Shift zero freq to center
mag = 20 * np.log10(np.abs(Fshift) + 1)     # Log scale for display

# ---- 3. Create Gaussian Filter Masks ----
rows, cols = img.shape
crow, ccol = rows // 2, cols // 2           # Center of the image

# Create a grid of (u, v) coordinates
u = np.arange(rows) - crow
v = np.arange(cols) - ccol
V, U = np.meshgrid(v, u)

# FIX 1: Euclidean Distance uses squares (**2), not multiplication (*2)
D = np.sqrt(U**2 + V**2)

D0 = 40                                     # Cutoff frequency (radius)

# FIX 2: Gaussian formula logic and syntax (explicit multiplication *)
# Formula: H = exp( -D^2 / (2 * D0^2) )
H_low = np.exp(-(D**2) / (2 * (D0**2)))     
H_high = 1 - H_low                          # HPF is the inverse of LPF

# ---- 4. Apply Filters in Frequency Domain ----
F_low = Fshift * H_low
F_high = Fshift * H_high

# ---- 5. Reconstruct Image (Inverse FFT) ----
# Low Pass Reconstruction
low_img_back = np.fft.ifftshift(F_low)      # Shift back
low_img = np.fft.ifft2(low_img_back)        # Inverse FFT
low_img = np.abs(low_img)                   # Magnitude

# High Pass Reconstruction
high_img_back = np.fft.ifftshift(F_high)
high_img = np.fft.ifft2(high_img_back)
high_img = np.abs(high_img)

# Normalize to 0-255 for display
low_disp = np.clip(low_img, 0, 255).astype(np.uint8)
high_disp = np.clip(high_img, 0, 255).astype(np.uint8)

# ---- 6. Visualization ----
titles = [
    "Original Image", "FFT Spectrum (Magnitude)",
    "Gaussian LPF (Blur)", "Gaussian HPF (Edges)"
]
images = [img, mag, low_disp, high_disp]

plt.figure(figsize=(12, 8))
for i, (t, im) in enumerate(zip(titles, images), 1):
    plt.subplot(2, 2, i)
    # Use gray cmap for all for consistency
    plt.imshow(im, cmap="gray") 
    plt.title(t)
    plt.axis("off")

plt.tight_layout()
plt.show()

# Optional: Save results
# cv2.imwrite("lowpass_out.png", low_disp)
# cv2.imwrite("highpass_out.png", high_disp)

# %%
#practical 10 
import cv2
import numpy as np
import matplotlib.pyplot as plt

# ---- Read grayscale image ----
img = cv2.imread(r"1.png", 0)
if img is None: raise FileNotFoundError("Check the image path")

# ===== Sobel (OpenCV) =====
sobel_x = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3)
sobel_y = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3)
sobel_mag = cv2.magnitude(sobel_x, sobel_y)

# ===== Prewitt =====
prewitt_kx = np.array([[-1,0,1],[-1,0,1],[-1,0,1]], np.float32)
prewitt_ky = np.array([[1,1,1],[0,0,0],[-1,-1,-1]], np.float32)
prewitt_x = cv2.filter2D(img, -1, prewitt_kx)
prewitt_y = cv2.filter2D(img, -1, prewitt_ky)
prewitt_mag = cv2.magnitude(prewitt_x.astype(np.float32), prewitt_y.astype(np.float32))

# ===== Roberts =====
roberts_kx = np.array([[1,0],[0,-1]], np.float32)
roberts_ky = np.array([[0,1],[-1,0]], np.float32)
roberts_x = cv2.filter2D(img, -1, roberts_kx)
roberts_y = cv2.filter2D(img, -1, roberts_ky)
roberts_mag = cv2.magnitude(roberts_x.astype(np.float32), roberts_y.astype(np.float32))

# ===== Laplacian =====
laplacian = cv2.Laplacian(img, cv2.CV_64F)

# ---- Display results ----
titles = [
    "Original",
    "Sobel Magnitude", "Prewitt Magnitude", "Roberts Magnitude",
    "Laplacian"
]
images = [
    img,
    sobel_mag, prewitt_mag, roberts_mag,
    laplacian
]

plt.figure(figsize=(12,6))
for i,(t,im) in enumerate(zip(titles, images), 1):
    plt.subplot(2,3,i)
    plt.imshow(im, cmap="gray")
    plt.title(t); plt.axis("off")
plt.tight_layout(); plt.show()

# %%
#practical 11

import cv2
import numpy as np
import matplotlib.pyplot as plt

# ---- Read grayscale image ----
img = cv2.imread(r"1.png", 0)
if img is None:
    raise FileNotFoundError("Check the image path")

# ---- Convert to binary (thresholding) ----
_, binary = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

# ---- Create structuring element (kernel) ----
kernel = np.ones((5, 5), np.uint8)

# ---- Morphological operations ----
erosion = cv2.erode(binary, kernel, iterations=1)
dilation = cv2.dilate(binary, kernel, iterations=1)

# ---- Show results ----
titles = ["Original Grayscale", "Binary", "Erosion", "Dilation"]
images = [img, binary, erosion, dilation]

plt.figure(figsize=(10,6))
for i, (t, im) in enumerate(zip(titles, images), 1):
    plt.subplot(2, 2, i)
    plt.imshow(im, cmap='gray')
    plt.title(t)
    plt.axis('off')
plt.tight_layout()
plt.show()


